<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Utilities</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "color.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
});
MathJax.Hub.Config({
    tex2jax: {inlineMath: [['^^','^^'], ['\\(', '\\)']]}
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v0.0.0</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of useful classes, functions and metafunctions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegsl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsl.html">gsl</a></td></tr>
<tr class="memdesc:namespacegsl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations from the Guideline Support Library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetmpl2"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetmpl2.html">tmpl2</a></td></tr>
<tr class="memdesc:namespacetmpl2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogramming things that are not planned to be submitted to Brigand. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDeferred.html">Deferred&lt; Rt &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides deferred or lazy evaluation of a function or function object, as well as efficient storage of an object that is mutable.  <a href="classDeferred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classInformer.html">Informer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classInformer.html" title="The Informer manages textual output regarding the status of a simulation. ">Informer</a> manages textual output regarding the status of a simulation.  <a href="classInformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContinuedFraction.html">ContinuedFraction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the continued fraction representation of a number.  <a href="classContinuedFraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContinuedFractionSummer.html">ContinuedFractionSummer&lt; Fraction &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum a continued fraction.  <a href="classContinuedFractionSummer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require a pointer to not be a <code>nullptr</code>  <a href="classgsl_1_1not__null.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNoSuchType.html">NoSuchType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to mark "no type" or "bad state" for metaprogramming.  <a href="structNoSuchType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOverloader.html">Overloader&lt; Fs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for overloading lambdas, useful for lambda-SFINAE.  <a href="classOverloader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPointerVector.html">PointerVector&lt; Type, AF, PF, TF, ExprResultType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A raw pointer endowed with expression template support via the Blaze library.  <a href="structPointerVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRational.html">Rational</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A rational number.  <a href="classRational.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticCache.html">StaticCache&lt; T, Ranges &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cache of objects intended to be stored in a static variable.  <a href="classStaticCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCacheRange.html">CacheRange&lt; Start, End &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of values for <a class="el" href="classStaticCache.html" title="A cache of objects intended to be stored in a static variable. ">StaticCache</a> indices. The <code>Start</code> is inclusive and the <code>End</code> is exclusive. The range must not be empty.  <a href="structCacheRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt; Tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An associative container that is indexed by structs.  <a href="classtuples_1_1TaggedTuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtmpl2_1_1value__list.html">tmpl2::value_list&lt; T,... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time list of values of the same type.  <a href="structtmpl2_1_1value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeDisplayer.html">TypeDisplayer&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get compiler error with type of template parameter.  <a href="structTypeDisplayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmake__list.html">make_list&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to turn a parameter pack into a typelist.  <a href="structmake__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcpp17_1_1void__type.html">cpp17::void_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a return type as being "void". In C++17 void is a regular type under certain circumstances, so this can be replaced by <code>void</code> then.  <a href="structcpp17_1_1void__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga265f35910bd218c59dd33acffe0c0b69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga265f35910bd218c59dd33acffe0c0b69">DEFINE_FAKE_VIRTUAL</a>(function)</td></tr>
<tr class="memdesc:ga265f35910bd218c59dd33acffe0c0b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function that acts similarly to a virtual function, but can take template parameters.  <a href="#ga265f35910bd218c59dd33acffe0c0b69">More...</a><br /></td></tr>
<tr class="separator:ga265f35910bd218c59dd33acffe0c0b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d571cd642604cb7bd87bb039ca3760f"><td class="memItemLeft" align="right" valign="top"><a id="ga9d571cd642604cb7bd87bb039ca3760f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9d571cd642604cb7bd87bb039ca3760f">SPECTRE_ALWAYS_INLINE</a>&#160;&#160;&#160;inline</td></tr>
<tr class="memdesc:ga9d571cd642604cb7bd87bb039ca3760f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always inline a function. Only use this if you benchmarked the code. <br /></td></tr>
<tr class="separator:ga9d571cd642604cb7bd87bb039ca3760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf62c1282f8b71500bbe2f4a4e945b66"><td class="memItemLeft" align="right" valign="top"><a id="gaaf62c1282f8b71500bbe2f4a4e945b66"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaaf62c1282f8b71500bbe2f4a4e945b66">SPECTRE_JUST_ALWAYS_INLINE</a></td></tr>
<tr class="memdesc:gaaf62c1282f8b71500bbe2f4a4e945b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always inline a function, but do not mark it <code>inline</code> <br /></td></tr>
<tr class="separator:gaaf62c1282f8b71500bbe2f4a4e945b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b776398a66e9a6bd561c8decf08b47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION_MACRO, ...)</td></tr>
<tr class="memdesc:gad7b776398a66e9a6bd561c8decf08b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro useful for generating many explicit instantiations of function or class templates.  <a href="#gad7b776398a66e9a6bd561c8decf08b47">More...</a><br /></td></tr>
<tr class="separator:gad7b776398a66e9a6bd561c8decf08b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffde14445f49f65ff4f5b592e44ee71a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaffde14445f49f65ff4f5b592e44ee71a">LIKELY</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:gaffde14445f49f65ff4f5b592e44ee71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10d0a221f4d7a706701b806c8135fd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab10d0a221f4d7a706701b806c8135fd7">UNLIKELY</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:gab10d0a221f4d7a706701b806c8135fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902d1cefbb10846eb8f5be9f6be5c340"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">EXPAND_PACK_LEFT_TO_RIGHT</a>(...)&#160;&#160;&#160;(void)<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt;char&gt; { ((void)(__VA_ARGS__), '0')... }</td></tr>
<tr class="memdesc:ga902d1cefbb10846eb8f5be9f6be5c340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a parameter pack evaluating the terms from left to right.  <a href="#ga902d1cefbb10846eb8f5be9f6be5c340">More...</a><br /></td></tr>
<tr class="separator:ga902d1cefbb10846eb8f5be9f6be5c340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf20b9d9f0e5870cc74c49bdf971e2cc6"><td class="memTemplParams" colspan="2">template&lt;typename Sequence &gt; </td></tr>
<tr class="memitem:gaf20b9d9f0e5870cc74c49bdf971e2cc6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf20b9d9f0e5870cc74c49bdf971e2cc6">make_boost_variant_over</a> = typename detail::make_boost_variant_over_impl&lt; Sequence &gt;::type</td></tr>
<tr class="memdesc:gaf20b9d9f0e5870cc74c49bdf971e2cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a boost::variant with all all the types inside the typelist Sequence.  <a href="#gaf20b9d9f0e5870cc74c49bdf971e2cc6">More...</a><br /></td></tr>
<tr class="separator:gaf20b9d9f0e5870cc74c49bdf971e2cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57946a2ff8730c87f1e47d636dd5b57"><td class="memTemplParams" colspan="2">template&lt;class T , Requires&lt; std::is_pointer&lt; T &gt;::value &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gae57946a2ff8730c87f1e47d636dd5b57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57">gsl::owner</a> = typename detail::owner_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:gae57946a2ff8730c87f1e47d636dd5b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a raw pointer as owning its data.  <a href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57">More...</a><br /></td></tr>
<tr class="separator:gae57946a2ff8730c87f1e47d636dd5b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084d535585c18d4e80f8ec6052d341a3"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:ga084d535585c18d4e80f8ec6052d341a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a> = typename Requires_detail::requires_impl&lt; B &gt;::template_error_type_failed_to_meet_requirements_on_template_parameters</td></tr>
<tr class="memdesc:ga084d535585c18d4e80f8ec6052d341a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Express requirements on the template parameters of a function or class, replaces <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code>  <a href="#ga084d535585c18d4e80f8ec6052d341a3">More...</a><br /></td></tr>
<tr class="separator:ga084d535585c18d4e80f8ec6052d341a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d33140d1e46af90392a957855ea2a83"><td class="memTemplParams" colspan="2"><a id="ga9d33140d1e46af90392a957855ea2a83"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9d33140d1e46af90392a957855ea2a83"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuples::TaggedTupleTypelist</b> = typename TaggedTuple_detail::tagged_tuple_typelist_impl&lt; T &gt;::type</td></tr>
<tr class="separator:ga9d33140d1e46af90392a957855ea2a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ee1794935080949a6995ae7d5e08cc"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga01ee1794935080949a6995ae7d5e08cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">tmpl2::flat_all</a> = <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool, Bs... &gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool,(static_cast&lt; void &gt;(Bs), true)... &gt; &gt;</td></tr>
<tr class="memdesc:ga01ee1794935080949a6995ae7d5e08cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical AND between bools 'B"".  <a href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">More...</a><br /></td></tr>
<tr class="separator:ga01ee1794935080949a6995ae7d5e08cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">tmpl2::flat_any</a> = <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, not <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool, Bs... &gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool,(static_cast&lt; void &gt;(Bs), false)... &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ga6e25dbfa539ff4513329969dbcd81c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical OR between bools 'B"".  <a href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">More...</a><br /></td></tr>
<tr class="separator:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabac5a3674cc25cc5907c3cdf772e72af"><td class="memTemplParams" colspan="2">template&lt;typename Rt , typename Fp , typename... Args&gt; </td></tr>
<tr class="memitem:gabac5a3674cc25cc5907c3cdf772e72af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDeferred.html">Deferred</a>&lt; Rt &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gabac5a3674cc25cc5907c3cdf772e72af">make_deferred</a> (Fp f, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:gabac5a3674cc25cc5907c3cdf772e72af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deferred function call object.  <a href="#gabac5a3674cc25cc5907c3cdf772e72af">More...</a><br /></td></tr>
<tr class="separator:gabac5a3674cc25cc5907c3cdf772e72af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada33ac747e1720e8d6c7d89323663c3e"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gada33ac747e1720e8d6c7d89323663c3e">info_from_build</a> ()</td></tr>
<tr class="memdesc:gada33ac747e1720e8d6c7d89323663c3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the version, date, host, git commit, and link time.  <a href="#gada33ac747e1720e8d6c7d89323663c3e">More...</a><br /></td></tr>
<tr class="separator:gada33ac747e1720e8d6c7d89323663c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga440a175ca29c1e92a7147f210a860932"><td class="memItemLeft" align="right" valign="top"><a id="ga440a175ca29c1e92a7147f210a860932"></a>
<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga440a175ca29c1e92a7147f210a860932">spectre_version</a> ()</td></tr>
<tr class="memdesc:ga440a175ca29c1e92a7147f210a860932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a string containing the current version of SpECTRE. <br /></td></tr>
<tr class="separator:ga440a175ca29c1e92a7147f210a860932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b2bffa5f55447db8d65c1e045d626a"><td class="memItemLeft" align="right" valign="top"><a id="ga36b2bffa5f55447db8d65c1e045d626a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga36b2bffa5f55447db8d65c1e045d626a">spectre_major_version</a> ()</td></tr>
<tr class="memdesc:ga36b2bffa5f55447db8d65c1e045d626a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns major version. <br /></td></tr>
<tr class="separator:ga36b2bffa5f55447db8d65c1e045d626a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddcfc56ecb94ec0577388d27f7431bb2"><td class="memItemLeft" align="right" valign="top"><a id="gaddcfc56ecb94ec0577388d27f7431bb2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaddcfc56ecb94ec0577388d27f7431bb2">spectre_minor_version</a> ()</td></tr>
<tr class="memdesc:gaddcfc56ecb94ec0577388d27f7431bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns minor version. <br /></td></tr>
<tr class="separator:gaddcfc56ecb94ec0577388d27f7431bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9158b176bca8b48872287187b6101250"><td class="memItemLeft" align="right" valign="top"><a id="ga9158b176bca8b48872287187b6101250"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9158b176bca8b48872287187b6101250">spectre_patch_version</a> ()</td></tr>
<tr class="memdesc:ga9158b176bca8b48872287187b6101250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns patch version. <br /></td></tr>
<tr class="separator:ga9158b176bca8b48872287187b6101250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3633a27b1636e458a5941a51810eb09f"><td class="memItemLeft" align="right" valign="top"><a id="ga3633a27b1636e458a5941a51810eb09f"></a>
<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga3633a27b1636e458a5941a51810eb09f">unit_test_path</a> () noexcept</td></tr>
<tr class="memdesc:ga3633a27b1636e458a5941a51810eb09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the path to the Unit test directory. <br /></td></tr>
<tr class="separator:ga3633a27b1636e458a5941a51810eb09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa46a305d87ee4ae9fede9d55c373286"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaaa46a305d87ee4ae9fede9d55c373286">ddot_</a> (const size_t &amp;N, const double *X, const size_t &amp;INCX, const double *Y, const size_t &amp;INCY)</td></tr>
<tr class="separator:gaaa46a305d87ee4ae9fede9d55c373286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e4641766bcfa0da87662aaba91037c"><td class="memTemplParams" colspan="2"><a id="ga32e4641766bcfa0da87662aaba91037c"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga32e4641766bcfa0da87662aaba91037c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga32e4641766bcfa0da87662aaba91037c">type_of_current_state</a> (const boost::variant&lt; Ts... &gt; &amp;variant) noexcept</td></tr>
<tr class="memdesc:ga32e4641766bcfa0da87662aaba91037c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type name of the current state of the boost::variant. <br /></td></tr>
<tr class="separator:ga32e4641766bcfa0da87662aaba91037c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867b9687621f42d8359074886e2d6283"><td class="memTemplParams" colspan="2"><a id="ga867b9687621f42d8359074886e2d6283"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga867b9687621f42d8359074886e2d6283"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga867b9687621f42d8359074886e2d6283">get_element</a> (T &amp;t, const size_t i) noexcept -&gt; decltype(t[i])</td></tr>
<tr class="memdesc:ga867b9687621f42d8359074886e2d6283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>i</code>th element if <code>T</code> has a subscript operator, otherwise if <code>T</code> is fundamental returns <code>t</code>. <br /></td></tr>
<tr class="separator:ga867b9687621f42d8359074886e2d6283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ba9a458f807cc77597f1b8f7b0dfc5"><td class="memTemplParams" colspan="2"><a id="ga08ba9a458f807cc77597f1b8f7b0dfc5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga08ba9a458f807cc77597f1b8f7b0dfc5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga08ba9a458f807cc77597f1b8f7b0dfc5">get_size</a> (const T &amp;t) noexcept -&gt; decltype(t.size())</td></tr>
<tr class="memdesc:ga08ba9a458f807cc77597f1b8f7b0dfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the size of <code>t</code> if <code>t.size()</code> is a valid expression, otherwise if <code>T</code> is fundamental returns 1. <br /></td></tr>
<tr class="separator:ga08ba9a458f807cc77597f1b8f7b0dfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memTemplParams" colspan="2"><a id="gaccb7d5132ccd60f32c504c51f9d7fb3c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaccb7d5132ccd60f32c504c51f9d7fb3c">dereference_wrapper</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reference object held by a reference wrapper, if a non-reference_wrapper type is passed in then the object is returned. <br /></td></tr>
<tr class="separator:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed84deeb606f239b8781809d2be69a6"><td class="memItemLeft" align="right" valign="top"><a id="ga6ed84deeb606f239b8781809d2be69a6"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga6ed84deeb606f239b8781809d2be69a6">equal_within_roundoff</a> (const double a, const double b, const double eps=<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt; double &gt;::epsilon() *100.0, const double scale=1.0) noexcept</td></tr>
<tr class="memdesc:ga6ed84deeb606f239b8781809d2be69a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two values <code>a</code> and <code>b</code> are equal within roundoff, by comparing <code>abs(a-b) &lt; ( max(abs(a),abs(b)) + scale) * eps</code> <br /></td></tr>
<tr class="separator:ga6ed84deeb606f239b8781809d2be69a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c00908b8856ad6d441d443d22586d0a"><td class="memTemplParams" colspan="2">template&lt;typename Fraction , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga6c00908b8856ad6d441d443d22586d0a"><td class="memTemplItemLeft" align="right" valign="top">Fraction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga6c00908b8856ad6d441d443d22586d0a">simplest_fraction_in_interval</a> (const T1 &amp;end1, const T2 &amp;end2) noexcept</td></tr>
<tr class="memdesc:ga6c00908b8856ad6d441d443d22586d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the fraction in the supplied interval with the smallest denominator.  <a href="#ga6c00908b8856ad6d441d443d22586d0a">More...</a><br /></td></tr>
<tr class="separator:ga6c00908b8856ad6d441d443d22586d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="memTemplParams" colspan="2"><a id="ga2da8b404f35c108209c4ce27c8d50e1c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2da8b404f35c108209c4ce27c8d50e1c">gsl::narrow_cast</a> (U &amp;&amp;u) noexcept</td></tr>
<tr class="memdesc:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <code>u</code> to a type <code>T</code> where the cast may result in narrowing. <br /></td></tr>
<tr class="separator:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memTemplParams" colspan="2"><a id="gafaf6db75ede2a9bc2fa4b6b17b8ef128"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gafaf6db75ede2a9bc2fa4b6b17b8ef128">gsl::narrow</a> (U u)</td></tr>
<tr class="memdesc:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="mdescLeft">&#160;</td><td class="mdescRight">A checked version of <a class="el" href="group__UtilitiesGroup.html#ga2da8b404f35c108209c4ce27c8d50e1c" title="Cast u to a type T where the cast may result in narrowing. ">narrow_cast()</a> that ERRORs if the cast changed the value. <br /></td></tr>
<tr class="separator:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c127d07f412267ea6548c8dab8b44c1"><td class="memItemLeft" align="right" valign="top"><a id="ga9c127d07f412267ea6548c8dab8b44c1"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9c127d07f412267ea6548c8dab8b44c1">operator&quot;&quot; _st</a> (const unsigned long long n)</td></tr>
<tr class="memdesc:ga9c127d07f412267ea6548c8dab8b44c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the _st size_t suffix. <br /></td></tr>
<tr class="separator:ga9c127d07f412267ea6548c8dab8b44c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ed7eef85864542bf2c2e212f86a533"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga08ed7eef85864542bf2c2e212f86a533"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga08ed7eef85864542bf2c2e212f86a533">make_array</a> (Args &amp;&amp;... args) noexcept(noexcept(MakeArray_detail::MakeArray&lt; Size==0 &gt;::template apply&lt; T &gt;(<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt;(Size==0 ? Size :Size - 1)&gt;{}, std::forward&lt; Args &gt;(args)...)))</td></tr>
<tr class="memdesc:ga08ed7eef85864542bf2c2e212f86a533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Size&gt;{{T(args...), T(args...), ...}}</code>  <a href="#ga08ed7eef85864542bf2c2e212f86a533">More...</a><br /></td></tr>
<tr class="separator:ga08ed7eef85864542bf2c2e212f86a533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac374515660115862e5ebbe0d27d49869"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename T &gt; </td></tr>
<tr class="memitem:gac374515660115862e5ebbe0d27d49869"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac374515660115862e5ebbe0d27d49869">make_array</a> (T &amp;&amp;t) noexcept(noexcept(MakeArray_detail::MakeArray&lt; Size==0 &gt;::template apply&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;&gt;(<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt;(Size==0 ? Size :Size - 1)&gt;{}, std::forward&lt; T &gt;(t))))</td></tr>
<tr class="memdesc:gac374515660115862e5ebbe0d27d49869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, Size&gt;{{t, t, ...}}</code>  <a href="#gac374515660115862e5ebbe0d27d49869">More...</a><br /></td></tr>
<tr class="separator:gac374515660115862e5ebbe0d27d49869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f579d55a04631539629be19103dcae"><td class="memTemplParams" colspan="2"><a id="ga18f579d55a04631539629be19103dcae"></a>
template&lt;typename T , typename... V, Requires&lt;(sizeof...(V) &gt; 0&gt; </td></tr>
<tr class="memitem:ga18f579d55a04631539629be19103dcae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; typename <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, sizeof...(V)+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga18f579d55a04631539629be19103dcae">make_array</a> (T &amp;&amp;t, V &amp;&amp;... values) noexcept(noexcept(<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, sizeof...(V)+1 &gt;{ {std::forward&lt; T &gt;(t), std::forward&lt; V &gt;(values)...}}))</td></tr>
<tr class="memdesc:ga18f579d55a04631539629be19103dcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to initialize a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a> with varying number of arguments. <br /></td></tr>
<tr class="separator:ga18f579d55a04631539629be19103dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea51ad2c5ef8f8f99279545e1389d056"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t size, typename Seq &gt; </td></tr>
<tr class="memitem:gaea51ad2c5ef8f8f99279545e1389d056"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaea51ad2c5ef8f8f99279545e1389d056">make_array</a> (Seq &amp;&amp;seq) noexcept(noexcept(MakeArray_detail::make_array_from_iterator_impl&lt; T, size &gt;(std::forward&lt; Seq &gt;(seq), <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; size &gt;{})))</td></tr>
<tr class="memdesc:gaea51ad2c5ef8f8f99279545e1389d056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt;</code> from the first <code>size</code> values of <code>seq</code>  <a href="#gaea51ad2c5ef8f8f99279545e1389d056">More...</a><br /></td></tr>
<tr class="separator:gaea51ad2c5ef8f8f99279545e1389d056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eed7cb45692393b257c3987070d1da2"><td class="memTemplParams" colspan="2"><a id="ga1eed7cb45692393b257c3987070d1da2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1eed7cb45692393b257c3987070d1da2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga1eed7cb45692393b257c3987070d1da2">number_of_digits</a> (const T number)</td></tr>
<tr class="memdesc:ga1eed7cb45692393b257c3987070d1da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of digits in an integer number. <br /></td></tr>
<tr class="separator:ga1eed7cb45692393b257c3987070d1da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad87825ee8984324e81a2ae6ab2fec6ed"><td class="memTemplParams" colspan="2"><a id="gad87825ee8984324e81a2ae6ab2fec6ed"></a>
template&lt;class... Fs&gt; </td></tr>
<tr class="memitem:gad87825ee8984324e81a2ae6ab2fec6ed"><td class="memTemplItemLeft" align="right" valign="top">OVERLOADER_CONSTEXPR <a class="el" href="classOverloader.html">Overloader</a>&lt; Fs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad87825ee8984324e81a2ae6ab2fec6ed">make_overloader</a> (Fs... fs)</td></tr>
<tr class="memdesc:gad87825ee8984324e81a2ae6ab2fec6ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code><a class="el" href="classOverloader.html" title="Used for overloading lambdas, useful for lambda-SFINAE. ">Overloader</a>&lt;Fs...&gt;</code>, see <a class="el" href="classOverloader.html" title="Used for overloading lambdas, useful for lambda-SFINAE. ">Overloader</a> for details. <br /></td></tr>
<tr class="separator:gad87825ee8984324e81a2ae6ab2fec6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5051536555a38beaf3cbe4784bb4002"><td class="memTemplParams" colspan="2"><a id="gab5051536555a38beaf3cbe4784bb4002"></a>
template&lt;typename... Ranges, typename Generator &gt; </td></tr>
<tr class="memitem:gab5051536555a38beaf3cbe4784bb4002"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab5051536555a38beaf3cbe4784bb4002">make_static_cache</a> (Generator &amp;&amp;generator) noexcept</td></tr>
<tr class="memdesc:gab5051536555a38beaf3cbe4784bb4002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classStaticCache.html" title="A cache of objects intended to be stored in a static variable. ">StaticCache</a>, inferring the cached type from the generator. <br /></td></tr>
<tr class="separator:gab5051536555a38beaf3cbe4784bb4002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcdd6af307bde8b3bf0650395c9768a7"><td class="memTemplParams" colspan="2"><a id="gadcdd6af307bde8b3bf0650395c9768a7"></a>
template&lt;size_t ElementToRemove, typename T , size_t Dim&gt; </td></tr>
<tr class="memitem:gadcdd6af307bde8b3bf0650395c9768a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gadcdd6af307bde8b3bf0650395c9768a7">all_but_specified_element_of</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gadcdd6af307bde8b3bf0650395c9768a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an existing array omitting one element. <br /></td></tr>
<tr class="separator:gadcdd6af307bde8b3bf0650395c9768a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabddc5fbff7dc002caf6472d5c782b11b"><td class="memTemplParams" colspan="2"><a id="gabddc5fbff7dc002caf6472d5c782b11b"></a>
template&lt;typename T , size_t Dim&gt; </td></tr>
<tr class="memitem:gabddc5fbff7dc002caf6472d5c782b11b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gabddc5fbff7dc002caf6472d5c782b11b">prepend</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;a, T value) noexcept</td></tr>
<tr class="memdesc:gabddc5fbff7dc002caf6472d5c782b11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an existing array prepending a value. <br /></td></tr>
<tr class="separator:gabddc5fbff7dc002caf6472d5c782b11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9752049086a20f017376e22ad169e47"><td class="memTemplParams" colspan="2"><a id="gaa9752049086a20f017376e22ad169e47"></a>
template&lt;typename T , size_t Dim, typename F &gt; </td></tr>
<tr class="memitem:gaa9752049086a20f017376e22ad169e47"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa9752049086a20f017376e22ad169e47">map_array</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;array, const F &amp;f) noexcept</td></tr>
<tr class="memdesc:gaa9752049086a20f017376e22ad169e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a function to each element of an array, producing a new array of the results. The elements of the new array are constructed in place, so they need not be default constructible. <br /></td></tr>
<tr class="separator:gaa9752049086a20f017376e22ad169e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49015243242c2caad5bdbd64ea7449a1"><td class="memTemplParams" colspan="2"><a id="ga49015243242c2caad5bdbd64ea7449a1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga49015243242c2caad5bdbd64ea7449a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga49015243242c2caad5bdbd64ea7449a1">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga49015243242c2caad5bdbd64ea7449a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>. <br /></td></tr>
<tr class="separator:ga49015243242c2caad5bdbd64ea7449a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8db62a17e01a839e499a4c59112df5"><td class="memTemplParams" colspan="2"><a id="ga4b8db62a17e01a839e499a4c59112df5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4b8db62a17e01a839e499a4c59112df5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga4b8db62a17e01a839e499a4c59112df5">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga4b8db62a17e01a839e499a4c59112df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>. <br /></td></tr>
<tr class="separator:ga4b8db62a17e01a839e499a4c59112df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acb5ffe1cdbc6f9fb1a506584f8f132"><td class="memTemplParams" colspan="2"><a id="ga3acb5ffe1cdbc6f9fb1a506584f8f132"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3acb5ffe1cdbc6f9fb1a506584f8f132"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga3acb5ffe1cdbc6f9fb1a506584f8f132">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga3acb5ffe1cdbc6f9fb1a506584f8f132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>. <br /></td></tr>
<tr class="separator:ga3acb5ffe1cdbc6f9fb1a506584f8f132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ca1c2d4ff05b9b2d683f207d58be92"><td class="memTemplParams" colspan="2"><a id="ga85ca1c2d4ff05b9b2d683f207d58be92"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ga85ca1c2d4ff05b9b2d683f207d58be92"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga85ca1c2d4ff05b9b2d683f207d58be92">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:ga85ca1c2d4ff05b9b2d683f207d58be92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>. <br /></td></tr>
<tr class="separator:ga85ca1c2d4ff05b9b2d683f207d58be92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81330e34bc91cfbd33c4d5272d33c53b"><td class="memTemplParams" colspan="2"><a id="ga81330e34bc91cfbd33c4d5272d33c53b"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga81330e34bc91cfbd33c4d5272d33c53b"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga81330e34bc91cfbd33c4d5272d33c53b">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Args... &gt; &amp;t)</td></tr>
<tr class="memdesc:ga81330e34bc91cfbd33c4d5272d33c53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for tuples. <br /></td></tr>
<tr class="separator:ga81330e34bc91cfbd33c4d5272d33c53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaa1563de19d53297daf7861a5170f2f"><td class="memTemplParams" colspan="2"><a id="gadaa1563de19d53297daf7861a5170f2f"></a>
template&lt;typename K , typename V , typename H &gt; </td></tr>
<tr class="memitem:gadaa1563de19d53297daf7861a5170f2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gadaa1563de19d53297daf7861a5170f2f">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;m)</td></tr>
<tr class="memdesc:gadaa1563de19d53297daf7861a5170f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all the key, value pairs of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>. <br /></td></tr>
<tr class="separator:gadaa1563de19d53297daf7861a5170f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa8b69f709871a3517de357ffaec062e"><td class="memTemplParams" colspan="2"><a id="gaaa8b69f709871a3517de357ffaec062e"></a>
template&lt;typename K , typename V , typename C &gt; </td></tr>
<tr class="memitem:gaaa8b69f709871a3517de357ffaec062e"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaaa8b69f709871a3517de357ffaec062e">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:gaaa8b69f709871a3517de357ffaec062e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all the key, value pairs of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>. <br /></td></tr>
<tr class="separator:gaaa8b69f709871a3517de357ffaec062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf389850e8ebc7d8040dfb5a50036f0ee"><td class="memTemplParams" colspan="2"><a id="gaf389850e8ebc7d8040dfb5a50036f0ee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf389850e8ebc7d8040dfb5a50036f0ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf389850e8ebc7d8040dfb5a50036f0ee">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:gaf389850e8ebc7d8040dfb5a50036f0ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>. <br /></td></tr>
<tr class="separator:gaf389850e8ebc7d8040dfb5a50036f0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23e067621bfcb4fcef006fd36b1a2909"><td class="memTemplParams" colspan="2"><a id="ga23e067621bfcb4fcef006fd36b1a2909"></a>
template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:ga23e067621bfcb4fcef006fd36b1a2909"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga23e067621bfcb4fcef006fd36b1a2909">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; T, C &gt; &amp;v)</td></tr>
<tr class="memdesc:ga23e067621bfcb4fcef006fd36b1a2909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>. <br /></td></tr>
<tr class="separator:ga23e067621bfcb4fcef006fd36b1a2909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4affaa7af20b9ab232a5cae60d1fd5"><td class="memTemplParams" colspan="2"><a id="ga5a4affaa7af20b9ab232a5cae60d1fd5"></a>
template&lt;typename T , Requires&lt; tt::is_streamable&lt; std::ostream, T &gt;::value &gt; &gt; </td></tr>
<tr class="memitem:ga5a4affaa7af20b9ab232a5cae60d1fd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga5a4affaa7af20b9ab232a5cae60d1fd5">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga5a4affaa7af20b9ab232a5cae60d1fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>. <br /></td></tr>
<tr class="separator:ga5a4affaa7af20b9ab232a5cae60d1fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78d6a6a95d4ebc4e5fca330a272a6182"><td class="memTemplParams" colspan="2"><a id="ga78d6a6a95d4ebc4e5fca330a272a6182"></a>
template&lt;typename T , Requires&lt; tt::is_streamable&lt; std::ostream, T &gt;::value &gt; &gt; </td></tr>
<tr class="memitem:ga78d6a6a95d4ebc4e5fca330a272a6182"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga78d6a6a95d4ebc4e5fca330a272a6182">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:ga78d6a6a95d4ebc4e5fca330a272a6182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>. <br /></td></tr>
<tr class="separator:ga78d6a6a95d4ebc4e5fca330a272a6182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcbd91b985044319a768092b12cd5045"><td class="memTemplParams" colspan="2"><a id="gadcbd91b985044319a768092b12cd5045"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gadcbd91b985044319a768092b12cd5045"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gadcbd91b985044319a768092b12cd5045">operator&lt;&lt;</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; T, U &gt; &amp;t)</td></tr>
<tr class="memdesc:gadcbd91b985044319a768092b12cd5045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>. <br /></td></tr>
<tr class="separator:gadcbd91b985044319a768092b12cd5045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495b431a620b10beb24f1afc90b77e20"><td class="memTemplParams" colspan="2"><a id="ga495b431a620b10beb24f1afc90b77e20"></a>
template&lt;typename K , typename V , typename H &gt; </td></tr>
<tr class="memitem:ga495b431a620b10beb24f1afc90b77e20"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga495b431a620b10beb24f1afc90b77e20">keys_of</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;m)</td></tr>
<tr class="memdesc:ga495b431a620b10beb24f1afc90b77e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string containing the keys of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>. <br /></td></tr>
<tr class="separator:ga495b431a620b10beb24f1afc90b77e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf707b57628e9425c91d92eb278a52c99"><td class="memTemplParams" colspan="2"><a id="gaf707b57628e9425c91d92eb278a52c99"></a>
template&lt;typename K , typename V , typename C &gt; </td></tr>
<tr class="memitem:gaf707b57628e9425c91d92eb278a52c99"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf707b57628e9425c91d92eb278a52c99">keys_of</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:gaf707b57628e9425c91d92eb278a52c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string containing the keys of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>. <br /></td></tr>
<tr class="separator:gaf707b57628e9425c91d92eb278a52c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9a7c7ee897f581360154a3676d5f7ab9">formatted_string</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;fmt, Args... args)</td></tr>
<tr class="memdesc:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string like printf.  <a href="#ga9a7c7ee897f581360154a3676d5f7ab9">More...</a><br /></td></tr>
<tr class="separator:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="memItemLeft" align="right" valign="top"><a id="gaa9e9df95875a2fa4b6ec2acfe7fa26ff"></a>
<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa9e9df95875a2fa4b6ec2acfe7fa26ff">current_date_and_time</a> ()</td></tr>
<tr class="memdesc:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current date and time. <br /></td></tr>
<tr class="separator:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45da409b9b03a4ad18e76036ab5a853c"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga45da409b9b03a4ad18e76036ab5a853c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c">expand_pack</a> (Ts &amp;&amp;...) noexcept</td></tr>
<tr class="memdesc:ga45da409b9b03a4ad18e76036ab5a853c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows zero-cost unordered expansion of a parameter.  <a href="#ga45da409b9b03a4ad18e76036ab5a853c">More...</a><br /></td></tr>
<tr class="separator:ga45da409b9b03a4ad18e76036ab5a853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde57eaa54272e77b438ea32c6891742"><td class="memTemplParams" colspan="2"><a id="gacde57eaa54272e77b438ea32c6891742"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:gacde57eaa54272e77b438ea32c6891742"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto) constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gacde57eaa54272e77b438ea32c6891742">get_first_argument</a> (T &amp;&amp;t, Ts &amp;&amp;...) noexcept</td></tr>
<tr class="memdesc:gacde57eaa54272e77b438ea32c6891742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first argument of a parameter pack. <br /></td></tr>
<tr class="separator:gacde57eaa54272e77b438ea32c6891742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65147320c04e61267089a58d71a6302"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:gad65147320c04e61267089a58d71a6302"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302">tuple_transform</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_transform_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(Elements)&gt;{}, args...)))</td></tr>
<tr class="memdesc:gad65147320c04e61267089a58d71a6302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a transform over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="#gad65147320c04e61267089a58d71a6302">More...</a><br /></td></tr>
<tr class="separator:gad65147320c04e61267089a58d71a6302"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab78389fadf763e3693ce893fad5d7fba"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:gab78389fadf763e3693ce893fad5d7fba"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab78389fadf763e3693ce893fad5d7fba">tmpl2::flat_all_v</a> = <a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">flat_all</a>&lt;Bs...&gt;::value</td></tr>
<tr class="memdesc:gab78389fadf763e3693ce893fad5d7fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical AND between bools 'B"".  <a href="group__UtilitiesGroup.html#gab78389fadf763e3693ce893fad5d7fba">More...</a><br /></td></tr>
<tr class="separator:gab78389fadf763e3693ce893fad5d7fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga8a328cb983ebb1947b0eb9d924f40253">tmpl2::flat_any_v</a> = <a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">flat_any</a>&lt;Bs...&gt;::value</td></tr>
<tr class="memdesc:ga8a328cb983ebb1947b0eb9d924f40253"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical OR between bools 'B"".  <a href="group__UtilitiesGroup.html#ga8a328cb983ebb1947b0eb9d924f40253">More...</a><br /></td></tr>
<tr class="separator:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5178d42622d5df3c47cdae8b027e5151"><td class="memTemplParams" colspan="2">template&lt;typename Rt , typename Fp , typename... Args&gt; </td></tr>
<tr class="memitem:ga5178d42622d5df3c47cdae8b027e5151"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga5178d42622d5df3c47cdae8b027e5151">update_deferred_args</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDeferred.html">Deferred</a>&lt; Rt &gt; *&gt; deferred, Fp, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga5178d42622d5df3c47cdae8b027e5151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the arguments to the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> function.  <a href="#ga5178d42622d5df3c47cdae8b027e5151">More...</a><br /></td></tr>
<tr class="separator:ga5178d42622d5df3c47cdae8b027e5151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420974cb5060a0d354a4d264703e11d0"><td class="memTemplParams" colspan="2">template&lt;typename Rt , typename Fp , typename... Args&gt; </td></tr>
<tr class="memitem:ga420974cb5060a0d354a4d264703e11d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga420974cb5060a0d354a4d264703e11d0">update_deferred_args</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDeferred.html">Deferred</a>&lt; Rt &gt; *&gt; deferred, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga420974cb5060a0d354a4d264703e11d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the arguments to the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> function.  <a href="#ga420974cb5060a0d354a4d264703e11d0">More...</a><br /></td></tr>
<tr class="separator:ga420974cb5060a0d354a4d264703e11d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac932a44b57087d32ce5341314437dbbd"><td class="memTemplParams" colspan="2">template&lt;bool UseLibXsmm = false&gt; </td></tr>
<tr class="memitem:gac932a44b57087d32ce5341314437dbbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac932a44b57087d32ce5341314437dbbd">dgemm_</a> (const char &amp;TRANSA, const char &amp;TRANSB, const size_t &amp;M, const size_t &amp;N, const size_t &amp;K, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *B, const size_t &amp;LDB, const double &amp;BETA, double *C, const size_t &amp;LDC)</td></tr>
<tr class="memdesc:gac932a44b57087d32ce5341314437dbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-matrix multiplication.  <a href="#gac932a44b57087d32ce5341314437dbbd">More...</a><br /></td></tr>
<tr class="separator:gac932a44b57087d32ce5341314437dbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaba62a62589ffc7b8b85a7722390f7ce0">dgemm_&lt; true &gt;</a> (const char &amp;TRANSA, const char &amp;TRANSB, const size_t &amp;M, const size_t &amp;N, const size_t &amp;K, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *B, const size_t &amp;LDB, const double &amp;BETA, double *C, const size_t &amp;LDC)</td></tr>
<tr class="memdesc:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-matrix multiplication.  <a href="#gaba62a62589ffc7b8b85a7722390f7ce0">More...</a><br /></td></tr>
<tr class="separator:gaba62a62589ffc7b8b85a7722390f7ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d31316e0975f0a66a60d9ac92756a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad4d31316e0975f0a66a60d9ac92756a8">dgemv_</a> (const char &amp;TRANS, const size_t &amp;M, const size_t &amp;N, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *X, const size_t &amp;INCX, const double &amp;BETA, double *Y, const size_t &amp;INCY)</td></tr>
<tr class="memdesc:gad4d31316e0975f0a66a60d9ac92756a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-vector multiplication.  <a href="#gad4d31316e0975f0a66a60d9ac92756a8">More...</a><br /></td></tr>
<tr class="separator:gad4d31316e0975f0a66a60d9ac92756a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="memTemplParams" colspan="2"><a id="ga818f101f2f8bd824a3bc7c2c2361c560"></a>
template&lt;class T , std::size_t N, typename Size &gt; </td></tr>
<tr class="memitem:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga818f101f2f8bd824a3bc7c2c2361c560">gsl::at</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;arr, Size index)</td></tr>
<tr class="memdesc:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. <br /></td></tr>
<tr class="separator:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1648d283e2a226cd398dbea1de84e88d"><td class="memTemplParams" colspan="2"><a id="ga1648d283e2a226cd398dbea1de84e88d"></a>
template&lt;class Cont , typename Size &gt; </td></tr>
<tr class="memitem:ga1648d283e2a226cd398dbea1de84e88d"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Cont::value_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga1648d283e2a226cd398dbea1de84e88d">gsl::at</a> (const Cont &amp;cont, Size index)</td></tr>
<tr class="memdesc:ga1648d283e2a226cd398dbea1de84e88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. <br /></td></tr>
<tr class="separator:ga1648d283e2a226cd398dbea1de84e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac75622e2034e12763b1e3989b813376b"><td class="memTemplParams" colspan="2"><a id="gac75622e2034e12763b1e3989b813376b"></a>
template&lt;class T , typename Size &gt; </td></tr>
<tr class="memitem:gac75622e2034e12763b1e3989b813376b"><td class="memTemplItemLeft" align="right" valign="top">constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac75622e2034e12763b1e3989b813376b">gsl::at</a> (<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; T &gt; cont, Size index)</td></tr>
<tr class="memdesc:gac75622e2034e12763b1e3989b813376b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. <br /></td></tr>
<tr class="separator:gac75622e2034e12763b1e3989b813376b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce4f7246dc4ad64d76817b8a988c056"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0ce4f7246dc4ad64d76817b8a988c056"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga0ce4f7246dc4ad64d76817b8a988c056">magnitude</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga0ce4f7246dc4ad64d76817b8a988c056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="#ga0ce4f7246dc4ad64d76817b8a988c056">More...</a><br /></td></tr>
<tr class="separator:ga0ce4f7246dc4ad64d76817b8a988c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d02f46cab8bbf00abc56508746cafde"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga2d02f46cab8bbf00abc56508746cafde"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2d02f46cab8bbf00abc56508746cafde">magnitude</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 1 &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga2d02f46cab8bbf00abc56508746cafde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="#ga2d02f46cab8bbf00abc56508746cafde">More...</a><br /></td></tr>
<tr class="separator:ga2d02f46cab8bbf00abc56508746cafde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd04562712892d6d8f77ff26e9646a19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacd04562712892d6d8f77ff26e9646a19"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gacd04562712892d6d8f77ff26e9646a19">magnitude</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gacd04562712892d6d8f77ff26e9646a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="#gacd04562712892d6d8f77ff26e9646a19">More...</a><br /></td></tr>
<tr class="separator:gacd04562712892d6d8f77ff26e9646a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae942ed628d83d2f9dbf39a06f2996395"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae942ed628d83d2f9dbf39a06f2996395"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gae942ed628d83d2f9dbf39a06f2996395">magnitude</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:gae942ed628d83d2f9dbf39a06f2996395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="#gae942ed628d83d2f9dbf39a06f2996395">More...</a><br /></td></tr>
<tr class="separator:gae942ed628d83d2f9dbf39a06f2996395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="memTemplParams" colspan="2"><a id="gaf29c2fe540b02e47a11c1ff9287bf169"></a>
template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Tag::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf29c2fe540b02e47a11c1ff9287bf169">tuples::get</a> (const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>. <br /></td></tr>
<tr class="separator:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0295bce7da8fd1957eecb2e0f31566a"><td class="memTemplParams" colspan="2"><a id="gaa0295bce7da8fd1957eecb2e0f31566a"></a>
template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:gaa0295bce7da8fd1957eecb2e0f31566a"><td class="memTemplItemLeft" align="right" valign="top">constexpr Tag::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa0295bce7da8fd1957eecb2e0f31566a">tuples::get</a> (<a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:gaa0295bce7da8fd1957eecb2e0f31566a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>. <br /></td></tr>
<tr class="separator:gaa0295bce7da8fd1957eecb2e0f31566a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b1f97e933f2b274b8b7f2d4e92ec32e"><td class="memTemplParams" colspan="2"><a id="ga3b1f97e933f2b274b8b7f2d4e92ec32e"></a>
template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:ga3b1f97e933f2b274b8b7f2d4e92ec32e"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Tag::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga3b1f97e933f2b274b8b7f2d4e92ec32e">tuples::get</a> (const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:ga3b1f97e933f2b274b8b7f2d4e92ec32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>. <br /></td></tr>
<tr class="separator:ga3b1f97e933f2b274b8b7f2d4e92ec32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30114b7db6af87e7e06e3ea6bac687eb"><td class="memTemplParams" colspan="2"><a id="ga30114b7db6af87e7e06e3ea6bac687eb"></a>
template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:ga30114b7db6af87e7e06e3ea6bac687eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr Tag::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga30114b7db6af87e7e06e3ea6bac687eb">tuples::get</a> (<a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&amp;t) noexcept</td></tr>
<tr class="memdesc:ga30114b7db6af87e7e06e3ea6bac687eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs. ">TaggedTuple</a>. <br /></td></tr>
<tr class="separator:ga30114b7db6af87e7e06e3ea6bac687eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91227dc4aa14972b7b2e7070719d061b"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:ga91227dc4aa14972b7b2e7070719d061b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_fold_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(Elements)&gt;{}, args...)))</td></tr>
<tr class="memdesc:ga91227dc4aa14972b7b2e7070719d061b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="#ga91227dc4aa14972b7b2e7070719d061b">More...</a><br /></td></tr>
<tr class="separator:ga91227dc4aa14972b7b2e7070719d061b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f67981c777b6762ada9da5ad5da11e7"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:ga3f67981c777b6762ada9da5ad5da11e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga3f67981c777b6762ada9da5ad5da11e7">tuple_counted_fold</a> (const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_counted_fold_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(Elements)&gt;{}, args...)))</td></tr>
<tr class="memdesc:ga3f67981c777b6762ada9da5ad5da11e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="#ga3f67981c777b6762ada9da5ad5da11e7">More...</a><br /></td></tr>
<tr class="separator:ga3f67981c777b6762ada9da5ad5da11e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A collection of useful classes, functions and metafunctions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga265f35910bd218c59dd33acffe0c0b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga265f35910bd218c59dd33acffe0c0b69">&#9670;&nbsp;</a></span>DEFINE_FAKE_VIRTUAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_FAKE_VIRTUAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="comment">/* This struct is only needed for producing an error if the function */</span>      \</div><div class="line">  <span class="comment">/* is not overridden in the derived class. */</span>                                \</div><div class="line">  template &lt;typename Base&gt;                                                     \</div><div class="line">  struct FakeVirtualInherit_##function : <span class="keyword">public</span> Base {                         \</div><div class="line">    using Base::Base;                                                          \</div><div class="line">    <span class="comment">/* clang-tidy: I think &quot;= delete&quot; was overlooked in the guideline */</span>       \</div><div class="line">    void <span class="keyword">function</span>(...) <span class="keyword">const</span> = <span class="keyword">delete</span>; <span class="comment">/* NOLINT */</span>                            \</div><div class="line">  };                                                                           \</div><div class="line">                                                                               \</div><div class="line">  template &lt;<span class="keyword">typename</span> Classes, <span class="keyword">typename</span>... TArgs, <span class="keyword">typename</span> Base,                \</div><div class="line">            typename... Args&gt;                                                  \</div><div class="line">  decltype(<span class="keyword">auto</span>) fake_virtual_<span class="preprocessor">##function(Base* obj, Args&amp;&amp;... args) noexcept { \</span></div><div class="line"><span class="preprocessor">    </span><span class="comment">/* clang-tidy: macro arg in parentheses */</span><span class="preprocessor">                                 \</span></div><div class="line"><span class="preprocessor">    return call_with_dynamic_type&lt;                                             \</span></div><div class="line"><span class="preprocessor">        decltype(obj-&gt;template function&lt;TArgs...&gt;(args...)), </span><span class="comment">/* NOLINT */</span><span class="preprocessor">      \</span></div><div class="line"><span class="preprocessor">        Classes&gt;(                                                              \</span></div><div class="line"><span class="preprocessor">        obj, [&amp;args...](auto* const dynamic_obj) noexcept -&gt; decltype(auto) {  \</span></div><div class="line"><span class="preprocessor">          static_assert(                                                       \</span></div><div class="line"><span class="preprocessor">              cpp17::is_base_of_v&lt;typename Base::Inherit,                      \</span></div><div class="line"><span class="preprocessor">                                  std::decay_t&lt;decltype(*dynamic_obj)&gt;&gt;,       \</span></div><div class="line"><span class="preprocessor">              &quot;Derived class does not inherit from Base::Inherit&quot;);            \</span></div><div class="line"><span class="preprocessor">          </span><span class="comment">/* clang-tidy: macro arg in parentheses */</span><span class="preprocessor">                           \</span></div><div class="line"><span class="preprocessor">          return dynamic_obj-&gt;template function&lt;TArgs...&gt;(</span><span class="comment">/* NOLINT */</span><span class="preprocessor">         \</span></div><div class="line"><span class="preprocessor">                                                          std::forward&lt;Args&gt;(  \</span></div><div class="line"><span class="preprocessor">                                                              args)...);       \</span></div><div class="line"><span class="preprocessor">        });                                                                    \</span></div><div class="line"><span class="preprocessor">  }</span></div></div><!-- fragment -->
<p>Define a function that acts similarly to a virtual function, but can take template parameters. </p>
<h3>Details</h3>
<p><code><a class="el" href="group__UtilitiesGroup.html#ga265f35910bd218c59dd33acffe0c0b69" title="Define a function that acts similarly to a virtual function, but can take template parameters...">DEFINE_FAKE_VIRTUAL(func)</a></code> defines the function <code>fake_virtual_func</code> and the struct <code>FakeVirtualInherit_func</code>. It should usually be called in a detail namespace.</p>
<p>A base class <code>Base</code> using this functionality should define a type </p><div class="fragment"><div class="line"><span class="keyword">using</span> Inherit = FakeVirtualInherit_func&lt;Base&gt;;</div></div><!-- fragment --><p> and a member function <code>func</code> wrapping <code>fake_virtual_func</code>, with the wrapper passing the derived classes as a typelist as the first template argument and the <code>this</code> pointer as the first normal argument.</p>
<p>Derived classes should then inherit from <code>Base::Inherit</code> instead of directly from <code>Base</code>. (<code>Base::Inherit</code> inherits from <code>Base</code>.)</p>
<p>If the base class has no pure virtual functions remaining it will generally be desirable to mark the constructors and assignment operators protected so that a bare base class cannot be instantiated.</p>
<p>If it is necessary to use multiple fake virtual functions with the same base class, the <code>Inherit</code> definition can nest the fake virtual classes: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Inherit = FakeVirtualInherit_func1&lt;FakeVirtualInherit_func2&lt;Base&gt;&gt;;</div></div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line"><a class="code" href="group__UtilitiesGroup.html#ga265f35910bd218c59dd33acffe0c0b69">DEFINE_FAKE_VIRTUAL</a>(fv)</div><div class="line"></div><div class="line"><span class="keyword">class </span>Derived;</div><div class="line"></div><div class="line"><span class="keyword">class </span>Base {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> Inherit = FakeVirtualInherit_fv&lt;Base&gt;;</div><div class="line"></div><div class="line"> <span class="keyword">protected</span>:</div><div class="line">  Base() = <span class="keywordflow">default</span>;</div><div class="line">  Base(<span class="keyword">const</span> Base&amp;) = <span class="keywordflow">default</span>;</div><div class="line">  Base(Base&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line">  Base&amp; operator=(<span class="keyword">const</span> Base&amp;) = <span class="keywordflow">default</span>;</div><div class="line">  Base&amp; operator=(Base&amp;&amp;) = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">  <span class="keywordtype">int</span> fv(<span class="keywordtype">int</span> x) {</div><div class="line">    <span class="keywordflow">return</span> fake_virtual_fv&lt;tmpl::list&lt;Derived&gt;, T&gt;(<span class="keyword">this</span>, x);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Derived : <span class="keyword">public</span> Base::Inherit {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">  <span class="keywordtype">int</span> fv(<span class="keywordtype">int</span> x) {</div><div class="line">    <span class="keywordflow">return</span> x + 3;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>call_with_dynamic_type </dd></dl>

</div>
</div>
<a id="ga902d1cefbb10846eb8f5be9f6be5c340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga902d1cefbb10846eb8f5be9f6be5c340">&#9670;&nbsp;</a></span>EXPAND_PACK_LEFT_TO_RIGHT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXPAND_PACK_LEFT_TO_RIGHT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;(void)<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt;char&gt; { ((void)(__VA_ARGS__), '0')... }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a parameter pack evaluating the terms from left to right. </p>
<p>The parameter pack inside the argument to the macro must not be expanded since the macro will do the expansion correctly for you. In the below example a parameter pack of <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;size_t, I&gt;</code> is passed to the function. The closure <code>lambda</code> is used to sum up the values of all the <code>Ts</code>. Note that the <code>Ts</code> passed to <code>EXPAND_PACK_LEFT_TO_RIGHT</code> is not expanded.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</div><div class="line"><span class="keywordtype">void</span> test_expand_pack_left_to_right(<span class="keyword">const</span> <span class="keywordtype">size_t</span> expected,</div><div class="line">                                    tmpl::list&lt;Ts...&gt; <span class="comment">/*meta*/</span>) {</div><div class="line">  <span class="keywordtype">size_t</span> sum = 0;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> lambda = [&amp;sum](<span class="keyword">auto</span> tag) { sum += decltype(tag)::value; };</div><div class="line">  <a class="code" href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">EXPAND_PACK_LEFT_TO_RIGHT</a>(lambda(Ts{}));</div><div class="line">  CHECK(sum == expected);</div><div class="line">}</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple. ">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga3f67981c777b6762ada9da5ad5da11e7" title="Perform a fold over a std::tuple. ">tuple_counted_fold</a> <a class="el" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple. ">tuple_transform</a> <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <a class="el" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c" title="Allows zero-cost unordered expansion of a parameter. ">expand_pack</a> </dd></dl>

</div>
</div>
<a id="gad7b776398a66e9a6bd561c8decf08b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b776398a66e9a6bd561c8decf08b47">&#9670;&nbsp;</a></span>GENERATE_INSTANTIATIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GENERATE_INSTANTIATIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">INSTANTIATION_MACRO, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">GENERATE_INSTANTIATIONS_DO_PRODUCT(                                    \</div><div class="line">      INSTANTIATION_MACRO,                                               \</div><div class="line">      BOOST_PP_LIST_TRANSFORM(GENERATE_INSTANTIATION_TUPLES_TO_LISTS, _, \</div><div class="line">                              BOOST_PP_VARIADIC_TO_LIST(__VA_ARGS__)))</div></div><!-- fragment -->
<p>Macro useful for generating many explicit instantiations of function or class templates. </p>
<p>It is often necessary to generate explicit instantiations of function or class templates. Since the total number of explicit instantiations scales as the product of the number of possible number of parameter values of each template parameter, this quickly becomes tedious. This macro allows you to easily generate hundreds of explicit instantiations.</p>
<p>The first argument to the macro is a macro that takes two arguments and is described below. The remaining arguments are macro-tuples, e.g. <code>(1, 2, 3)</code>. The Cartesian product of the macro-tuples is then computed and each term is passed as a tuple as the second argument to the <code>INSTANTIATION_MACRO</code>. The first argument to the <code>INSTANTIATION_MACRO</code> is a Boost.Preprocessor internal variable so just make it <code>_</code>. The <code>INSTANTIATION(_, data)</code> macro below serves as an example. A concrete example is generating explicit instantiations of the class <code><a class="el" href="classIndex.html" title="An integer multi-index. ">Index</a>&lt;Dim&gt;</code> for <code>Dim = 0,1,2,3</code>, which you would do as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GET_DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define INSTANTIATION(_, data)         \</span></div><div class="line"><span class="preprocessor">  template class Index&lt;GET_DIM(data)&gt;;</span></div><div class="line"></div><div class="line"><a class="code" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION, (0, 1, 2, 3))</div><div class="line"></div><div class="line"><span class="preprocessor">#undef GET_DIM</span></div><div class="line"><span class="preprocessor">#undef INSTANTIATION</span></div></div><!-- fragment --><p>This will generate:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;0&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;1&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;2&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;3&gt;</a>;</div></div><!-- fragment --><p>It is also possible to generate explicit instantiations for multiple classes or functions in a single call to <code>GENERATE_INSTANTIATIONS</code>. For example, the (in)equivalence operators can be generated using:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GET_DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div><div class="line"><span class="preprocessor">#define GEN_OP(op, dim)                            \</span></div><div class="line"><span class="preprocessor">  template bool operator op(const Index&lt;dim&gt;&amp; lhs, \</span></div><div class="line"><span class="preprocessor">                            const Index&lt;dim&gt;&amp; rhs) noexcept;</span></div><div class="line"><span class="preprocessor">#define INSTANTIATION(_, data)         \</span></div><div class="line"><span class="preprocessor">  template class Index&lt;GET_DIM(data)&gt;; \</span></div><div class="line"><span class="preprocessor">  GEN_OP(==, GET_DIM(data))            \</span></div><div class="line"><span class="preprocessor">  GEN_OP(!=, GET_DIM(data))</span></div><div class="line"></div><div class="line"><a class="code" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION, (0, 1, 2, 3))</div><div class="line"></div><div class="line"><span class="preprocessor">#undef GET_DIM</span></div><div class="line"><span class="preprocessor">#undef GEN_OP</span></div><div class="line"><span class="preprocessor">#undef INSTANTIATION</span></div></div><!-- fragment --><p>which will result in the instantiations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;0&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;1&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;2&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;3&gt;</a>;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; rhs) noexcept;</div><div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; rhs) noexcept;</div></div><!-- fragment --><p>Now let's look at generating instantiations of member function templates of class templates, which will be a common use case. In this example we generate explicit instantiations of all the member function templates of the class <code><a class="el" href="classScalarWave_1_1Solutions_1_1PlaneWave.html" title="A plane wave solution to the Euclidean wave equation. ">ScalarWave::Solutions::PlaneWave</a></code>. In total, for <code>Dim = 1,2,3</code> and types <code>double</code> and <code><a class="el" href="classDataVector.html" title="Stores a collection of function values. ">DataVector</a></code> this is about 42 explicit instantiations, which would be extremely annoying to write by hand. The macro code is surprisingly simple:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div><div class="line"><span class="preprocessor">#define DTYPE(data) BOOST_PP_TUPLE_ELEM(1, data)</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define INSTANTIATE(_, data)                                              \</span></div><div class="line"><span class="preprocessor">  template Scalar&lt;DTYPE(data)&gt;                                            \</span></div><div class="line"><span class="preprocessor">  ScalarWave::Solutions::PlaneWave&lt;DIM(data)&gt;::psi(                       \</span></div><div class="line"><span class="preprocessor">      const tnsr::I&lt;DTYPE(data), DIM(data)&gt;&amp; x, double t) const noexcept; \</span></div><div class="line"><span class="preprocessor">  template Scalar&lt;DTYPE(data)&gt;                                            \</span></div><div class="line"><span class="preprocessor">  ScalarWave::Solutions::PlaneWave&lt;DIM(data)&gt;::dpsi_dt(                   \</span></div><div class="line"><span class="preprocessor">      const tnsr::I&lt;DTYPE(data), DIM(data)&gt;&amp; x, double t) const noexcept;</span></div><div class="line"></div><div class="line"><a class="code" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATE, (1, 2, 3), (<span class="keywordtype">double</span>, <a class="code" href="classDataVector.html">DataVector</a>))</div><div class="line"></div><div class="line"><span class="preprocessor">#undef DIM</span></div><div class="line"><span class="preprocessor">#undef DTYPE</span></div><div class="line"><span class="preprocessor">#undef INSTANTIATE</span></div></div><!-- fragment --><p>We don't show the result from preprocessor since for all of the member functions of <code>PlaneWave</code> the total output is approximately 150 lines, but you can hopefully see the benefits of generating explicit instantiations using the <code>GENERATE_INSTANTIATIONS</code> way.</p>
<p>One thing that can be difficult is debugging metaprograms (be they template or macro-based). To this end we provide a make target <code>DebugPreprocessor</code> which prints the output of running the preprocessor on the file <code>src/Executables/DebugPreprocessor/DebugPreprocessor.cpp</code>. Note that the output of the <code>GENERATE_INSTANTIATIONS</code> macro will be on a single line, so it often proves useful to copy-paste the output into an editor and run clang-format over the code so it's easier to reason about. </p>

</div>
</div>
<a id="gaffde14445f49f65ff4f5b592e44ee71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffde14445f49f65ff4f5b592e44ee71a">&#9670;&nbsp;</a></span>LIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The if statement is expected to evaluate true most of the time </p>

</div>
</div>
<a id="gab10d0a221f4d7a706701b806c8135fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10d0a221f4d7a706701b806c8135fd7">&#9670;&nbsp;</a></span>UNLIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNLIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The if statement is expected to evaluate false most of the time </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga01ee1794935080949a6995ae7d5e08cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ee1794935080949a6995ae7d5e08cc">&#9670;&nbsp;</a></span>flat_all</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">tmpl2::flat_all</a> = typedef <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt;<a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, Bs...&gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, (static_cast&lt;void&gt;(Bs), true)...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical AND between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="el" href="structcpp17_1_1conjunction.html" title="A logical AND on the template parameters. ">cpp17::conjunction</a> and <a class="el" href="structcpp17_1_1disjunction.html" title="A logical OR on the template parameters. ">cpp17::disjunction</a> use recursion </p>

</div>
</div>
<a id="ga6e25dbfa539ff4513329969dbcd81c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e25dbfa539ff4513329969dbcd81c40">&#9670;&nbsp;</a></span>flat_any</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">tmpl2::flat_any</a> = typedef <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, not <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, Bs...&gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, (static_cast&lt;void&gt;(Bs), false)...&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical OR between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="el" href="structcpp17_1_1conjunction.html" title="A logical AND on the template parameters. ">cpp17::conjunction</a> and <a class="el" href="structcpp17_1_1disjunction.html" title="A logical OR on the template parameters. ">cpp17::disjunction</a> use recursion </p>

</div>
</div>
<a id="gaf20b9d9f0e5870cc74c49bdf971e2cc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf20b9d9f0e5870cc74c49bdf971e2cc6">&#9670;&nbsp;</a></span>make_boost_variant_over</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#gaf20b9d9f0e5870cc74c49bdf971e2cc6">make_boost_variant_over</a> =  typename detail::make_boost_variant_over_impl&lt;Sequence&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a boost::variant with all all the types inside the typelist Sequence. </p>
<p><em>Returns:</em> boost::variant of all types inside <code>Sequence</code> </p>

</div>
</div>
<a id="gae57946a2ff8730c87f1e47d636dd5b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae57946a2ff8730c87f1e47d636dd5b57">&#9670;&nbsp;</a></span>owner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , Requires&lt; std::is_pointer&lt; T &gt;::value &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57">gsl::owner</a> = typedef typename detail::owner_impl&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a raw pointer as owning its data. </p>
<dl class="section warning"><dt>Warning</dt><dd>You should never actually use <code><a class="el" href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57" title="Mark a raw pointer as owning its data. ">gsl::owner</a></code>. Instead you should use <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code>, and if shared ownership is required, <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a></code>. </dd></dl>

</div>
</div>
<a id="ga084d535585c18d4e80f8ec6052d341a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084d535585c18d4e80f8ec6052d341a3">&#9670;&nbsp;</a></span>Requires</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a> =  typename Requires_detail::requires_impl&lt; B&gt;::template_error_type_failed_to_meet_requirements_on_template_parameters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Express requirements on the template parameters of a function or class, replaces <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> </p>
<p>Replacement for <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> and Concepts for expressing requirements on template parameters. This does not require merging of the Concepts TS (whose merit is debatable) and provides an "error message" if substitution of a template parameter failed. Specifically, the compiler error will contain "template_error_type_failed_to_meet_requirements_on_template_parameters", aiding the user of a function or class in tracking down the list of requirements on the deduced type.</p>
<p>For example, if a function <code>foo</code> is defined as: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::vector, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;vector&quot;</span>;</div><div class="line">}</div></div><!-- fragment --><p>then calling the function with a list, <code>foo(<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt;double&gt;{});</code> results in the following compilation error from clang: </p><div class="fragment"><div class="line">./tests/Unit/Utilities/Test_Requires.cpp:29:3: error: no matching <span class="keyword">function</span></div><div class="line">   <span class="keywordflow">for</span> <a class="code" href="namespacepypp.html#aecc213d312cdaa74c7d2e63a55a960df">call</a> to <span class="stringliteral">&#39;foo&#39;</span></div><div class="line">  foo(<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/list.html">std::list&lt;double&gt;</a>{});</div><div class="line">  ^~~</div><div class="line">./tests/Unit/Utilities/Test_Requires.cpp:15:13: note: candidate</div><div class="line">    <span class="keyword">template</span> ignored: substitution failure [with T = std::__1::list&lt;double,</div><div class="line">    std::__1::allocator&lt;double&gt; &gt;]: no type named</div><div class="line">    <span class="stringliteral">&#39;template_error_type_failed_to_meet_requirements_on_template_parameters&#39;</span></div><div class="line">    in <span class="stringliteral">&#39;Requires_detail::requires_impl&lt;false&gt;&#39;</span></div><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp;) {</div><div class="line">            ^</div><div class="line">1 error generated.</div></div><!-- fragment --><p>Here is an example of how write function overloads using <code>Requires</code> or to express constraints on the template parameters: </p><div class="fragment"><div class="line"><span class="comment">/// [foo_definition]</span></div><div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::vector, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;vector&quot;</span>;</div><div class="line">}<span class="comment"></span></div><div class="line"><span class="comment">/// [foo_definition]</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::list, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div><div class="line"><a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div><div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;list&quot;</span>;</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Using <code>Requires</code> is safer than using <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> because the nested type alias is of type <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/nullptr_t.html">std::nullptr_t</a></code> and so usage is always: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;(<span class="keywordtype">bool</span> depending on T)&gt; = <span class="keywordtype">nullptr</span>&gt;</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaa46a305d87ee4ae9fede9d55c373286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa46a305d87ee4ae9fede9d55c373286">&#9670;&nbsp;</a></span>ddot_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ddot_ </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dot product of two vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>the length of the vectors. </td></tr>
    <tr><td class="paramname">X</td><td>a pointer to the first element of the first vector. </td></tr>
    <tr><td class="paramname">INCX</td><td>the stride for the elements of the first vector. </td></tr>
    <tr><td class="paramname">Y</td><td>a pointer to the first element of the second vector. </td></tr>
    <tr><td class="paramname">INCY</td><td>the stride for the elements of the second vector. </td></tr>
  </table>
  </dd>
</dl>
<p><em>Returns:</em> the dot product of the given vectors. </p>

</div>
</div>
<a id="gac932a44b57087d32ce5341314437dbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac932a44b57087d32ce5341314437dbbd">&#9670;&nbsp;</a></span>dgemm_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseLibXsmm = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dgemm_ </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-matrix multiplication. </p>
<p>Perform the matrix-matrix multiplication </p><p class="formulaDsp">
\[ C = \alpha \mathrm{op}(A) \mathrm{op}(B) + \beta \mathrm{op}(C) \]
</p>
<p>where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<p>LIBXSMM, which is much faster than BLAS for small matrices, can be called instead of BLAS by passing the template parameter <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANSA</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">TRANSB</td><td>either 'N', 'T' or 'C', transposition of matrix B </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(B)\) and \(\mathrm{op}(C)\) </td></tr>
    <tr><td class="paramname">K</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage. ">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage. ">Matrix</a> \(B\) </td></tr>
    <tr><td class="paramname">LDB</td><td>Specifies first dimension of \(\mathrm{op}(B)\) </td></tr>
    <tr><td class="paramname">BETA</td><td>specifies \(\beta\) </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage. ">Matrix</a> \(C\) </td></tr>
    <tr><td class="paramname">LDC</td><td>Specifies first dimension of \(\mathrm{op}(C)\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UseLibXsmm</td><td>if <code>true</code> then use LIBXSMM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba62a62589ffc7b8b85a7722390f7ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba62a62589ffc7b8b85a7722390f7ce0">&#9670;&nbsp;</a></span>dgemm_< true >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__UtilitiesGroup.html#gac932a44b57087d32ce5341314437dbbd">dgemm_</a>&lt; true &gt; </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-matrix multiplication. </p>
<p>Perform the matrix-matrix multiplication </p><p class="formulaDsp">
\[ C = \alpha \mathrm{op}(A) \mathrm{op}(B) + \beta \mathrm{op}(C) \]
</p>
<p>where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<p>LIBXSMM, which is much faster than BLAS for small matrices, can be called instead of BLAS by passing the template parameter <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANSA</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">TRANSB</td><td>either 'N', 'T' or 'C', transposition of matrix B </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(B)\) and \(\mathrm{op}(C)\) </td></tr>
    <tr><td class="paramname">K</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage. ">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage. ">Matrix</a> \(B\) </td></tr>
    <tr><td class="paramname">LDB</td><td>Specifies first dimension of \(\mathrm{op}(B)\) </td></tr>
    <tr><td class="paramname">BETA</td><td>specifies \(\beta\) </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage. ">Matrix</a> \(C\) </td></tr>
    <tr><td class="paramname">LDC</td><td>Specifies first dimension of \(\mathrm{op}(C)\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UseLibXsmm</td><td>if <code>true</code> then use LIBXSMM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4d31316e0975f0a66a60d9ac92756a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d31316e0975f0a66a60d9ac92756a8">&#9670;&nbsp;</a></span>dgemv_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dgemv_ </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-vector multiplication. </p>
<p class="formulaDsp">
\[ y = \alpha \mathrm{op}(A) x + \beta y \]
</p>
<p>where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANS</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage. ">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">X</td><td>Vector \(x\) </td></tr>
    <tr><td class="paramname">INCX</td><td>Specifies the increment for the elements of \(x\) </td></tr>
    <tr><td class="paramname">BETA</td><td>Specifies \(\beta\) </td></tr>
    <tr><td class="paramname">Y</td><td>Vector \(y\) </td></tr>
    <tr><td class="paramname">INCY</td><td>Specifies the increment for the elements of \(y\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45da409b9b03a4ad18e76036ab5a853c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45da409b9b03a4ad18e76036ab5a853c">&#9670;&nbsp;</a></span>expand_pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void expand_pack </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows zero-cost unordered expansion of a parameter. </p>
<h3>Details</h3>
<p>Expands a parameter pack, typically useful for runtime evaluation via a Callable such as a lambda, function, or function object. For example, an unordered transform of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> can be implemented as: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Elements, <span class="keywordtype">size_t</span>... Is&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">transform</a>(<span class="keyword">const</span> <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Elements...&gt;</a>&amp; tupull,</div><div class="line">               <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Elements...&gt;</a>&amp; out_tupull,</div><div class="line">               <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::index_sequence&lt;Is...&gt;</a> <span class="comment">/*meta*/</span>) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> func = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; in, <span class="keyword">auto</span>&amp; out) {</div><div class="line">    out = in * <span class="keyword">static_cast&lt;</span>decltype(in)<span class="keyword">&gt;</span>(2);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">  };</div><div class="line">  <a class="code" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c">expand_pack</a>(func(std::get&lt;Is&gt;(tupull), std::get&lt;Is&gt;(out_tupull))...);</div><div class="line">}</div><div class="line">}  <span class="comment">// namespace</span></div><div class="line"></div><div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Utilities.expand_pack&quot;</span>, <span class="stringliteral">&quot;[Utilities][Unit]&quot;</span>) {</div><div class="line">  <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, double, float&gt;</a> my_tupull = std::make_tuple(3, 2.7, 8.2);</div><div class="line">  <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, double, float&gt;</a> my_tupull_output;</div><div class="line">  <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">transform</a>(my_tupull, my_tupull_output, <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence&lt;3&gt;</a>{});</div><div class="line">  CHECK(std::get&lt;0&gt;(my_tupull_output) == 6);</div><div class="line">  CHECK(std::get&lt;1&gt;(my_tupull_output) == 5.4);</div><div class="line">  CHECK(std::get&lt;2&gt;(my_tupull_output) == 16.4f);</div><div class="line">}</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple. ">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga3f67981c777b6762ada9da5ad5da11e7" title="Perform a fold over a std::tuple. ">tuple_counted_fold</a> <a class="el" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple. ">tuple_transform</a> <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <a class="el" href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340" title="Expand a parameter pack evaluating the terms from left to right. ">EXPAND_PACK_LEFT_TO_RIGHT</a> </dd></dl>

</div>
</div>
<a id="ga9a7c7ee897f581360154a3676d5f7ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7c7ee897f581360154a3676d5f7ab9">&#9670;&nbsp;</a></span>formatted_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> formatted_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a string like printf. </p>
<p>Given a formatting string and arguments this returns the corresponding string. Similar to printf but using std::strings. </p>

</div>
</div>
<a id="gada33ac747e1720e8d6c7d89323663c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada33ac747e1720e8d6c7d89323663c3e">&#9670;&nbsp;</a></span>info_from_build()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> info_from_build </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Information about the version, date, host, git commit, and link time. </p>
<p>The information returned by this function is invaluable for identifying the version of the code used in a simulation, as well as which host, the date the code was compiled, and the time of linkage. </p>

</div>
</div>
<a id="ga0ce4f7246dc4ad64d76817b8a988c056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ce4f7246dc4ad64d76817b8a988c056">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p>If T is a container the magnitude is computed separately for each element of the container.</p>
<p><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), sqrt(), and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="ga2d02f46cab8bbf00abc56508746cafde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d02f46cab8bbf00abc56508746cafde">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p>If T is a container the magnitude is computed separately for each element of the container.</p>
<p><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), sqrt(), and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="gacd04562712892d6d8f77ff26e9646a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd04562712892d6d8f77ff26e9646a19">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p>If T is a container the magnitude is computed separately for each element of the container.</p>
<p><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), sqrt(), and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="gae942ed628d83d2f9dbf39a06f2996395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae942ed628d83d2f9dbf39a06f2996395">&#9670;&nbsp;</a></span>magnitude() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p>If T is a container the magnitude is computed separately for each element of the container.</p>
<p><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), sqrt(), and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="ga08ed7eef85864542bf2c2e212f86a533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08ed7eef85864542bf2c2e212f86a533">&#9670;&nbsp;</a></span>make_array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Size&gt; make_array </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Size&gt;{{T(args...), T(args...), ...}}</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size</td><td>the size of the array </td></tr>
    <tr><td class="paramname">T</td><td>the type of the element in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac374515660115862e5ebbe0d27d49869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac374515660115862e5ebbe0d27d49869">&#9670;&nbsp;</a></span>make_array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, Size&gt; make_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, Size&gt;{{t, t, ...}}</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size</td><td>the size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea51ad2c5ef8f8f99279545e1389d056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea51ad2c5ef8f8f99279545e1389d056">&#9670;&nbsp;</a></span>make_array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t size, typename Seq &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt; make_array </td>
          <td>(</td>
          <td class="paramtype">Seq &amp;&amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt;</code> from the first <code>size</code> values of <code>seq</code> </p>
<p><em>Requires:</em> <code>Seq</code> has a <code>begin</code> function </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type held by the array </td></tr>
    <tr><td class="paramname">size</td><td>the size of the created array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabac5a3674cc25cc5907c3cdf772e72af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabac5a3674cc25cc5907c3cdf772e72af">&#9670;&nbsp;</a></span>make_deferred()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rt , typename Fp , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDeferred.html">Deferred</a>&lt;Rt&gt; make_deferred </td>
          <td>(</td>
          <td class="paramtype">Fp&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a deferred function call object. </p>
<p>If creating a <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> with a function object the call operator of the function object must be marked <code>const</code> currently. Since the function object will only be evaluated once there currently seems to be no reason to allow mutating call operators.</p>
<h3>Example</h3>
<p>The examples below use the following functions: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>func {</div><div class="line">  <span class="keywordtype">double</span> operator()()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 8.2; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> dummy() { <span class="keywordflow">return</span> 6.7; }</div><div class="line"></div><div class="line"><span class="keyword">struct </span>func2 {</div><div class="line">  <span class="keywordtype">double</span> operator()(<span class="keyword">const</span> <span class="keywordtype">double</span>&amp; t)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> t; }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> lazy_function(<span class="keyword">const</span> <span class="keywordtype">double</span> t) { <span class="keywordflow">return</span> 10.0 * t; }</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> mutate_function(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> t, <span class="keyword">const</span> <span class="keywordtype">double</span> t0) {</div><div class="line">  *t = t0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> mutate_function_vector(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>*&gt; t,</div><div class="line">                            <span class="keyword">const</span> <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t0) {</div><div class="line">  <span class="keywordflow">if</span> (t-&gt;size() != t0.size()) {</div><div class="line">    t-&gt;resize(t0.size(), 0.0);</div><div class="line">  }</div><div class="line">  <span class="comment">// Check the size again just to be sure the resize above happened.</span></div><div class="line">  CHECK(t-&gt;size() == t0.size());</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; t-&gt;size(); ++i) {</div><div class="line">    t-&gt;operator[](i) = 10.0 * t0[i];</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>To create a <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> using a function object use: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> def = make_deferred&lt;double&gt;(func{});</div><div class="line">  CHECK(8.2 == def.get());</div></div><!-- fragment --><p>or using a regular function: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> def2 = make_deferred&lt;double&gt;(dummy);</div><div class="line">  CHECK(6.7 == def2.get());</div></div><!-- fragment --><p> It is also possible to pass <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> objects to a deferred function call: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> def2 = make_deferred&lt;double&gt;(func2{}, 6.82);</div><div class="line">  <span class="keyword">auto</span> def3 = make_deferred&lt;double&gt;(lazy_function, def2);</div><div class="line">  CHECK(68.2 == def3.get());</div><div class="line">  CHECK(6.82 == def2.get());</div></div><!-- fragment --><p>in which case the first function will be evaluated just before the second function is evaluated.</p>
<p>In addition to functions that return by value, it is also possible to use functions that return by reference. The first argument of the function must then be a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr ">gsl::not_null</a>&lt;Rt*&gt;</code>, and can be mutated inside the function. The mutating functions are primarily useful if <code>Rt</code> performs heap allocations and is frequently recomputed in a manner where the heap allocation could be avoided.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rt</td><td>the type of the object returned by the function </td></tr>
  </table>
  </dd>
</dl>
<p><em>Returns:</em> <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> object that will lazily evaluate the function </p>

</div>
</div>
<a id="ga6c00908b8856ad6d441d443d22586d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c00908b8856ad6d441d443d22586d0a">&#9670;&nbsp;</a></span>simplest_fraction_in_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fraction , typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Fraction simplest_fraction_in_interval </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the fraction in the supplied interval with the smallest denominator. </p>
<p>The endpoints are considered to be in the interval. The order of the arguments is not significant. The answer is unique as long as the interval has length less than 1; for longer intervals, an integer in the range will be returned. </p>

</div>
</div>
<a id="ga3f67981c777b6762ada9da5ad5da11e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f67981c777b6762ada9da5ad5da11e7">&#9670;&nbsp;</a></span>tuple_counted_fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_counted_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a fold over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p>Iterates over the elements in a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right (left fold) calling <code>op(element, args...)</code> on each element in <code>tuple</code>. A right fold can be done by explicitly setting the first template parameter to true. Folds are easily implemented using <code>tuple_fold</code> by updating one of the <code>args...</code> at each iteration. If you need the index of the current element you can use the <code>tuple_counted_fold</code> variant. <code>tuple_counted_fold</code> passes the current index as the second argument to the Callable <code>op</code>. That is, <code>op(element, index, args...)</code>.</p>
<h3>Example</h3>
<p>The sum of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> of Arithmetics can be computed in several ways. First, you can use a lambda: </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">    <span class="keywordtype">double</span> sum_value = 0.0;</div><div class="line">    <a class="code" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull,</div><div class="line">               [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keywordtype">double</span>&amp; state) { state += element; },</div><div class="line">               sum_value);</div><div class="line">    CHECK(sum_value == approx(26.1));</div></div><!-- fragment --><p>You'll notice that <code>state</code> is taken by reference and mutated.</p>
<p>You can do the same thing with a struct defined as </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>tuple_fold_plus {</div><div class="line">  T value = 0.0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> S&amp; element) {</div><div class="line">    value += element;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>and then using an instance of the struct </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">    tuple_fold_plus&lt;double&gt; sum_value{};</div><div class="line">    <a class="code" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull, sum_value);</div><div class="line">    CHECK(sum_value.value == approx(26.1));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You are not able to pass a function pointer to <code>tuple_fold</code> or <code>tuple_counted_fold</code> because you cannot pass a pointer to a function template, only a function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c" title="Allows zero-cost unordered expansion of a parameter. ">expand_pack</a> <a class="el" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple. ">tuple_transform</a> <a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple. ">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga3f67981c777b6762ada9da5ad5da11e7" title="Perform a fold over a std::tuple. ">tuple_counted_fold</a> <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

</div>
</div>
<a id="ga91227dc4aa14972b7b2e7070719d061b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91227dc4aa14972b7b2e7070719d061b">&#9670;&nbsp;</a></span>tuple_fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a fold over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p>Iterates over the elements in a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right (left fold) calling <code>op(element, args...)</code> on each element in <code>tuple</code>. A right fold can be done by explicitly setting the first template parameter to true. Folds are easily implemented using <code>tuple_fold</code> by updating one of the <code>args...</code> at each iteration. If you need the index of the current element you can use the <code>tuple_counted_fold</code> variant. <code>tuple_counted_fold</code> passes the current index as the second argument to the Callable <code>op</code>. That is, <code>op(element, index, args...)</code>.</p>
<h3>Example</h3>
<p>The sum of a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> of Arithmetics can be computed in several ways. First, you can use a lambda: </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">    <span class="keywordtype">double</span> sum_value = 0.0;</div><div class="line">    <a class="code" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull,</div><div class="line">               [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keywordtype">double</span>&amp; state) { state += element; },</div><div class="line">               sum_value);</div><div class="line">    CHECK(sum_value == approx(26.1));</div></div><!-- fragment --><p>You'll notice that <code>state</code> is taken by reference and mutated.</p>
<p>You can do the same thing with a struct defined as </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>tuple_fold_plus {</div><div class="line">  T value = 0.0;</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> S&amp; element) {</div><div class="line">    value += element;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p>and then using an instance of the struct </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">    tuple_fold_plus&lt;double&gt; sum_value{};</div><div class="line">    <a class="code" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull, sum_value);</div><div class="line">    CHECK(sum_value.value == approx(26.1));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You are not able to pass a function pointer to <code>tuple_fold</code> or <code>tuple_counted_fold</code> because you cannot pass a pointer to a function template, only a function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c" title="Allows zero-cost unordered expansion of a parameter. ">expand_pack</a> <a class="el" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple. ">tuple_transform</a> <a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple. ">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga3f67981c777b6762ada9da5ad5da11e7" title="Perform a fold over a std::tuple. ">tuple_counted_fold</a> <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

</div>
</div>
<a id="gad65147320c04e61267089a58d71a6302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65147320c04e61267089a58d71a6302">&#9670;&nbsp;</a></span>tuple_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a transform over a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p>Iterates over the elements in a <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right calling <code>op.operator()(element, index, args...)</code> on each element in <code>tuple</code>. A right-to-left transform can be done by explicitly setting the first template parameter to true. The second argument of the invokable will be a deduced <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;size_t, value&gt;</code>, from which the current index can be extracted by using <code>decltype(index)::value</code>. For a function object the <code>decltype(index)</code> can be replaced by the deduced type of <code>index</code>. For example, </p><div class="fragment"><div class="line"><span class="keyword">struct </span>negate {</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Index, <span class="keyword">typename</span> S&gt;</div><div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> T&amp; element, <a class="code" href="classIndex.html">Index</a> <span class="comment">/*index*/</span>,</div><div class="line">                  S&amp; second_tuple_element) <span class="keyword">const</span> noexcept {</div><div class="line">    std::get&lt;Index::value&gt;(second_tuple_element) = -element;</div><div class="line">  }</div><div class="line">};</div></div><!-- fragment --><p> Using <code>tuple_transform</code> with a generic lambda goes as follows, </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div><div class="line">  <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t&lt;decltype(my_tupull)&gt;</a> out_tupull;</div><div class="line">  <a class="code" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302">tuple_transform</a>(my_tupull,</div><div class="line">                  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keyword">auto</span> index, <span class="keyword">auto</span>&amp; out_tuple) {</div><div class="line">                    constexpr <span class="keywordtype">size_t</span> index_v = decltype(index)::value;</div><div class="line">                    std::get&lt;index_v&gt;(out_tuple) = -element;</div><div class="line">                  },</div><div class="line">                  out_tupull);</div><div class="line"></div><div class="line">  CHECK(std::get&lt;0&gt;(out_tupull) == -2);</div><div class="line">  CHECK(std::get&lt;1&gt;(out_tupull) == -7);</div><div class="line">  CHECK(std::get&lt;2&gt;(out_tupull) == 3.8);</div><div class="line">  CHECK(std::get&lt;3&gt;(out_tupull) == -20.9);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c" title="Allows zero-cost unordered expansion of a parameter. ">expand_pack</a> <a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple. ">tuple_fold</a> <a class="el" href="group__UtilitiesGroup.html#ga3f67981c777b6762ada9da5ad5da11e7" title="Perform a fold over a std::tuple. ">tuple_counted_fold</a> <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

</div>
</div>
<a id="ga5178d42622d5df3c47cdae8b027e5151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5178d42622d5df3c47cdae8b027e5151">&#9670;&nbsp;</a></span>update_deferred_args() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rt , typename Fp , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void update_deferred_args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDeferred.html">Deferred</a>&lt; Rt &gt; *&gt;&#160;</td>
          <td class="paramname"><em>deferred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fp&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the arguments to the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> function. </p>
<p>In order to make mutating <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> functions really powerful, the <code>args</code> to them must be updated without destructing the held <code>Rt</code> object. The type of <code>Fp</code> (the invokable being lazily evaluated) as well as the types of the <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;Args&gt;...</code> must match their respective types at the time of creation of the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> object.</p>
<h3>Example</h3>
<p>You can avoid specifying the type of the function held by the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> class by passing the function as a second argument: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> mutate_deferred = make_deferred&lt;std::vector&lt;double&gt;&gt;(</div><div class="line">      mutate_function_vector, <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{1.3, 7.8, 9.8});</div><div class="line">  CHECK(mutate_deferred.get() == (<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{13., 78., 98.}));</div><div class="line">  <a class="code" href="group__UtilitiesGroup.html#ga5178d42622d5df3c47cdae8b027e5151">update_deferred_args</a>(<a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;mutate_deferred), mutate_function_vector,</div><div class="line">                       <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{10., 70., 90.});</div><div class="line">  CHECK(mutate_deferred.get() == (<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{100., 700., 900.}));</div></div><!-- fragment --><p> You can also specify the type of the function held by the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> explicitly as follows: </p><div class="fragment"><div class="line">  update_deferred_args&lt;std::vector&lt;double&gt;, decltype(mutate_function_vector)&gt;(</div><div class="line">      &amp;mutate_deferred, <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{20., 8., 9.});</div><div class="line">  CHECK(mutate_deferred.get() == (<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{200., 80., 90.}));</div></div><!-- fragment -->
</div>
</div>
<a id="ga420974cb5060a0d354a4d264703e11d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420974cb5060a0d354a4d264703e11d0">&#9670;&nbsp;</a></span>update_deferred_args() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rt , typename Fp , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void update_deferred_args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classDeferred.html">Deferred</a>&lt; Rt &gt; *&gt;&#160;</td>
          <td class="paramname"><em>deferred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the arguments to the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> function. </p>
<p>In order to make mutating <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> functions really powerful, the <code>args</code> to them must be updated without destructing the held <code>Rt</code> object. The type of <code>Fp</code> (the invokable being lazily evaluated) as well as the types of the <code><a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;Args&gt;...</code> must match their respective types at the time of creation of the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> object.</p>
<h3>Example</h3>
<p>You can avoid specifying the type of the function held by the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> class by passing the function as a second argument: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> mutate_deferred = make_deferred&lt;std::vector&lt;double&gt;&gt;(</div><div class="line">      mutate_function_vector, <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{1.3, 7.8, 9.8});</div><div class="line">  CHECK(mutate_deferred.get() == (<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{13., 78., 98.}));</div><div class="line">  <a class="code" href="group__UtilitiesGroup.html#ga5178d42622d5df3c47cdae8b027e5151">update_deferred_args</a>(<a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;mutate_deferred), mutate_function_vector,</div><div class="line">                       <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{10., 70., 90.});</div><div class="line">  CHECK(mutate_deferred.get() == (<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{100., 700., 900.}));</div></div><!-- fragment --><p> You can also specify the type of the function held by the <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> explicitly as follows: </p><div class="fragment"><div class="line">  update_deferred_args&lt;std::vector&lt;double&gt;, decltype(mutate_function_vector)&gt;(</div><div class="line">      &amp;mutate_deferred, <a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{20., 8., 9.});</div><div class="line">  CHECK(mutate_deferred.get() == (<a class="codeRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{200., 80., 90.}));</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gab78389fadf763e3693ce893fad5d7fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab78389fadf763e3693ce893fad5d7fba">&#9670;&nbsp;</a></span>flat_all_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tmpl2::flat_all_v = <a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">flat_all</a>&lt;Bs...&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical AND between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="el" href="structcpp17_1_1conjunction.html" title="A logical AND on the template parameters. ">cpp17::conjunction</a> and <a class="el" href="structcpp17_1_1disjunction.html" title="A logical OR on the template parameters. ">cpp17::disjunction</a> use recursion </p>

</div>
</div>
<a id="ga8a328cb983ebb1947b0eb9d924f40253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a328cb983ebb1947b0eb9d924f40253">&#9670;&nbsp;</a></span>flat_any_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tmpl2::flat_any_v = <a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">flat_any</a>&lt;Bs...&gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical OR between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="el" href="structcpp17_1_1conjunction.html" title="A logical AND on the template parameters. ">cpp17::conjunction</a> and <a class="el" href="structcpp17_1_1disjunction.html" title="A logical OR on the template parameters. ">cpp17::disjunction</a> use recursion </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2018
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
